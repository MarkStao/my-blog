import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as t,d as l,a as n,b as a,o as r}from"./app-B14rnIJD.js";const d="/my-blog/assets/SpringAOP%E5%92%8CAspectJAOP%E7%9A%84%E5%8C%BA%E5%88%AB-DL8Uj3fE.png",s="/my-blog/assets/SpringMVC%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B-BN7jo6PS.png",p="/my-blog/assets/Restful%E2%BB%9B%E6%A0%BC%E7%9A%84%E6%8E%A5%E2%BC%9D%E6%B5%81%E7%A8%8B-CNvjwdma.png",o={};function g(h,i){return r(),t("div",null,[i[0]||(i[0]=l("p",null,"Spring是一个轻量级、非侵入式的控制反转（IoC）和面向切面（AOP）的框架。",-1)),n(" more "),i[1]||(i[1]=a('<h2 id="spring基础" tabindex="-1"><a class="header-anchor" href="#spring基础"><span>Spring基础</span></a></h2><p>Spring是一个轻量级、非侵入式的控制反转（IoC）和面向切面（AOP）的框架。</p><h3 id="spring的特性" tabindex="-1"><a class="header-anchor" href="#spring的特性"><span>Spring的特性</span></a></h3><ul><li>Ioc和DI支持</li><li>AOP编程支持</li><li>声明式事务支持</li><li>快捷测试支持</li><li>快速集成支持</li><li>复杂API模板封装</li></ul><h3 id="spring的七大主要模块" tabindex="-1"><a class="header-anchor" href="#spring的七大主要模块"><span>Spring的七大主要模块</span></a></h3><ul><li>Spring Core：Spring核心，提供控制反转和依赖注入特性；</li><li>Spring Context：Spring上下文容器，提供对bean的配置、管理、依赖注入等功能；</li><li>Spring Web：提供对Web应用的支持，包括Servlet、JSP、Struts、Spring MVC等；</li><li>Spring MVC：提供MVC思想的实现；</li><li>Spring DAO：提供JDBC抽象，简化DAO层的开发；</li><li>Spring ORM：支持流行的ORM框架的整合；</li><li>Spring AOP：面向切面编程，提供了与AOP联盟兼容的编程实现。</li></ul><h3 id="spring常用注解" tabindex="-1"><a class="header-anchor" href="#spring常用注解"><span>Spring常用注解</span></a></h3><table><thead><tr><th>分类</th><th>注解</th><th>作用</th></tr></thead><tbody><tr><td>Web</td><td>@Controller</td><td>标记用于处理Web请求的类</td></tr><tr><td>Web</td><td>@RestController</td><td>@Controller和@ResponseBody的组合</td></tr><tr><td>Web</td><td>@RequestMapping</td><td>用于将请求路径映射到处理方法</td></tr><tr><td>Web</td><td>@RequestBody</td><td>将请求参数转换成Java对象</td></tr><tr><td>Web</td><td>@ResponseBody</td><td>直接将返回数据写入响应体中</td></tr><tr><td>Web</td><td>@PathVariable</td><td>将URL的参数映射到方法参数</td></tr><tr><td>容器</td><td>@Component</td><td>将类标记为容器中的组件</td></tr><tr><td>容器</td><td>@Service</td><td>将类标记为业务服务组件</td></tr><tr><td>容器</td><td>@Repository</td><td>将类标记为数据访问组件</td></tr><tr><td>容器</td><td>@Autowired</td><td>用于依赖注入</td></tr><tr><td>容器</td><td>@Qualifier</td><td>用于依赖注入时，指定具体实现类</td></tr><tr><td>容器</td><td>@Value</td><td>用于从配置文件中注入值</td></tr><tr><td>容器</td><td>@Configuration</td><td>将类标记为配置类</td></tr><tr><td>容器</td><td>@Bean</td><td>将方法返回的对象标记为容器中的Bean</td></tr><tr><td>容器</td><td>@Scope</td><td>定义Bean的作用范围</td></tr><tr><td>AOP</td><td>@Aspect</td><td>将类标记为切面类</td></tr><tr><td>AOP</td><td>@Pointcut</td><td>定义切点</td></tr><tr><td>AOP</td><td>@Before</td><td>前置通知，在被切的方法执行前执行</td></tr><tr><td>AOP</td><td>@After</td><td>后置通知，在被切的方法执行后执行，比return更后</td></tr><tr><td>AOP</td><td>@AfterRunning</td><td>返回通知，在被切的方法return后执行</td></tr><tr><td>AOP</td><td>@AfterThrowing</td><td>异常通知，在被切的方法抛异常时执行</td></tr><tr><td>AOP</td><td>@Around</td><td>环绕通知，在被切的方法执行前和后执行</td></tr><tr><td>事务</td><td>@Transactional</td><td>用于声明式事务管理，标记类或方法为事务方法</td></tr></tbody></table><h3 id="spring主要使用的设计模式" tabindex="-1"><a class="header-anchor" href="#spring主要使用的设计模式"><span>Spring主要使用的设计模式</span></a></h3><ul><li>工厂模式</li><li>单例模式</li><li>原型模式</li><li>代理模式</li><li>适配器模式</li><li>装饰器模式</li><li>观察者模式</li><li>模板方法模式</li><li>策略模式</li></ul><hr><h2 id="控制反转-ioc" tabindex="-1"><a class="header-anchor" href="#控制反转-ioc"><span>控制反转（IoC）</span></a></h2><p>控制反转（IoC）是由容器来控制对象的生命周期和对象间的关系。<br> 依赖注入（DI）是控制反转的实现方式。</p><h3 id="springbean的生命周期" tabindex="-1"><a class="header-anchor" href="#springbean的生命周期"><span>SpringBean的生命周期</span></a></h3><ul><li>实例化：通过构造器或工厂方法创建bean实例</li><li>属性赋值：通过setter方法或者构造器为bean的属性赋值</li><li>初始化：初始化bean实例，执行初始化方法</li><li>使用：bean实例被程序使用</li><li>销毁：销毁bean实例，执行销毁方法</li></ul><h3 id="bean定义和依赖定义方式" tabindex="-1"><a class="header-anchor" href="#bean定义和依赖定义方式"><span>Bean定义和依赖定义方式</span></a></h3><ul><li>直接编码方式</li><li>配置文件方式</li><li>注解方式</li></ul><h3 id="依赖注入的方法" tabindex="-1"><a class="header-anchor" href="#依赖注入的方法"><span>依赖注入的方法</span></a></h3><ul><li>构造器注入</li><li>属性注入</li><li>工厂方法注入</li></ul><h3 id="自动装配" tabindex="-1"><a class="header-anchor" href="#自动装配"><span>自动装配</span></a></h3><p>Spring IoC容器知道所有Bean的配置信息，此外，通过Java反射机制还可以获知实现类的结构信息，如构造⽅法的结构、属性等信息。掌握所有Bean的这些信息后，Spring IoC容器就可以按照某种规则对容器中的Bean进⾏⾃动装配，⽽⽆须通过显式的⽅式进⾏依赖配置。</p><h3 id="自动装配的方式" tabindex="-1"><a class="header-anchor" href="#自动装配的方式"><span>自动装配的方式</span></a></h3><ul><li>byName：根据属性名进行自动装配</li><li>byType：根据属性类型进行自动装配</li><li>constructor：根据构造器进行自动装配</li><li>autodetect：根据自省机制自动装配</li></ul><h3 id="autowired注解自动装配的过程" tabindex="-1"><a class="header-anchor" href="#autowired注解自动装配的过程"><span>@Autowired注解自动装配的过程</span></a></h3><ol><li>Spring容器启动会创建并维护所有的Bean的定义信息；</li><li>当遇到@Autowired注解时，会在Bean初始阶段通过AutowiredAnnotationBeanPostProcessor处理自动装配逻辑；</li><li>装配过程先解析注入点，获取目标类型；</li><li>按类型装配，会查找与目标类型一致的所有Bean；</li><li>如果指定@Qualifier，则进一步按照名称匹配；</li><li>当查到多个Bean时，Spring会通过以下方式解决歧义性： <ul><li>优先选择带@Primary注解的Bean；</li><li>选择与依赖名称匹配的Bean；</li><li>按照@Order顺序获取</li></ul></li><li>如果没有匹配到，则会抛出NoSuchBeanDefinitionException。</li></ol><h3 id="bean的作用域" tabindex="-1"><a class="header-anchor" href="#bean的作用域"><span>Bean的作用域</span></a></h3><ul><li>singleton：单例，默认值，容器中只会有一个实例</li><li>prototype：多例，每次获取bean都会创建一个新的实例</li><li>request：每次HTTP请求都会创建一个新的实例</li><li>session：每次HTTP会话都会创建一个新的实例</li><li>globalSession：每次全局会话都会创建一个新的实例</li><li>application：每次Web应用都会创建一个新的实例</li><li>webSocket：每次WebSocket会话都会创建一个新的实例</li><li>other：自定义作用域</li></ul><h3 id="循环依赖" tabindex="-1"><a class="header-anchor" href="#循环依赖"><span>循环依赖</span></a></h3><p>循环依赖指在Bean初始化过程中，A依赖B，B依赖A，这样两个Bean就形成了循环依赖。</p><h3 id="循环依赖解决" tabindex="-1"><a class="header-anchor" href="#循环依赖解决"><span>循环依赖解决</span></a></h3><p>Spring通过三级缓存机制解决单例Bean循环依赖问题</p><ol><li>在Bean创建过程中，Spring会先实例化对象，然后将其放入三级缓存中，此时对象还未完成属性注入和初始化；</li><li>当发生循环依赖时，依赖方会从三级缓存中获取到目标Bean的ObjectFactory，通过getObject()方法获取到早期引用；</li><li>三级缓存的结构包括：singletonObjects（存放创建成功的Bean）、earlySingletonObjects（存放创建中的Bean）和singletonFactories（存放ObjectFactory，用于获取早期引用）</li><li>整个过程遵循“先暴露后完善”的原则，允许Bean在未完全初始化就被其它Bean引用。</li></ol><h3 id="简易ioc容器实现" tabindex="-1"><a class="header-anchor" href="#简易ioc容器实现"><span>简易Ioc容器实现</span></a></h3><ol><li>定义容器接口，提供基本都Bean获取和管理功能；</li><li>容器初始化时扫描指定路径下的类，并通过反射实例化类，并保存到容器中；</li><li>Bean的作用域管理，区分单例和原型；</li><li>实现AOP功能，通过代理在Bean初始化前后写入逻辑。<br> 整个过程中，工厂模式用于Bean创建，策略模式处理不同作用域，代理模式实现AOP。</li></ol><h3 id="spring、spring-mvc和spring-boot的区别" tabindex="-1"><a class="header-anchor" href="#spring、spring-mvc和spring-boot的区别"><span>Spring、Spring MVC和Spring Boot的区别</span></a></h3><ul><li>Spring是整个生态的基础框架，提供IoC容器和AOP等核心功能；</li><li>Spring MVC是基于Spring的Web框架，处理Http请求和响应，实现MVC模式；</li><li>Spring Boot是Spring的扩展，通过自动配置和起步依赖简化Spring应用的初始搭建和开发过程。</li></ul><h3 id="spring启动几乎实例化所有bean的原因" tabindex="-1"><a class="header-anchor" href="#spring启动几乎实例化所有bean的原因"><span>Spring启动几乎实例化所有Bean的原因</span></a></h3><ul><li>尽早发现问题：能立即发现配置错误或依赖缺失问题；</li><li>保持一致性：避免运行时因Bean初始化顺序或线程安全问题导致的异常；</li><li>运行时性能更优：所有Bean都已初始化完成，不需要再处理依赖关系。</li></ul><h3 id="spring优化启动时间" tabindex="-1"><a class="header-anchor" href="#spring优化启动时间"><span>Spring优化启动时间</span></a></h3><ul><li>使用@Lazy注解标记可延迟加载的Bean</li><li>合理设置Bean的作用域</li><li>使用Spring Boot的懒加载配置</li><li>大型应用可以采用模块化加载</li></ul><hr><h2 id="面向切面-aop" tabindex="-1"><a class="header-anchor" href="#面向切面-aop"><span>面向切面（AOP）</span></a></h2><p>⾯向切⾯编程。简单说，就是把⼀些业务逻辑中的相同的代码抽取到⼀个独⽴的模块中，让业务逻辑更加清爽。</p><h3 id="aop的理解" tabindex="-1"><a class="header-anchor" href="#aop的理解"><span>AOP的理解</span></a></h3><p>AOP是面向切面编程，核心思想是将横切关注点（日志、事务、安全等）从业务逻辑分离出来。通过代理模式实现，在运行时动态地将代码切入到类的指定方法或位置。<br> 核心概念包括：</p><ul><li>切面（Aspect）：封装横切关注点的模块</li><li>连接点（JoinPoint）：程序执行过程中的特定点</li><li>切点（Pointcut）：匹配连接点的表达式</li><li>通知（Advice）：在连接点上执行的动作</li></ul><h3 id="spring-aop和aspectj-aop的区别" tabindex="-1"><a class="header-anchor" href="#spring-aop和aspectj-aop的区别"><span>Spring AOP和AspectJ AOP的区别</span></a></h3><figure><img src="'+d+'" alt="Spring AOP和AspectJ AOP的区别" tabindex="0" loading="lazy"><figcaption>Spring AOP和AspectJ AOP的区别</figcaption></figure><hr><h2 id="事务" tabindex="-1"><a class="header-anchor" href="#事务"><span>事务</span></a></h2><h3 id="编程式事务" tabindex="-1"><a class="header-anchor" href="#编程式事务"><span>编程式事务</span></a></h3><p>编程式事务管理使⽤ TransactionTemplate，需要显式执⾏事务。</p><h3 id="声明式事务" tabindex="-1"><a class="header-anchor" href="#声明式事务"><span>声明式事务</span></a></h3><p>本质是通过AOP进行前后拦截实现，声明式事务管理使⽤@Transactional注解，只能在类或者方法上使用。</p><h3 id="spring的事务隔离级别" tabindex="-1"><a class="header-anchor" href="#spring的事务隔离级别"><span>Spring的事务隔离级别</span></a></h3><ul><li>READ_UNCOMMITTED：读未提交，允许脏读、不可重复读和幻读。</li><li>READ_COMMITTED：读已提交，不允许脏读，但允许不可重复读和幻读。</li><li>REPEATABLE_READ：可重复读，不允许脏读、不可重复读，但允许幻读。</li><li>SERIALIZABLE：串行化，不允许脏读、不可重复读和幻读。</li><li>READ_COMMITTED：默认使用数据库的隔离级别</li></ul><h3 id="声明式事务的失效情况" tabindex="-1"><a class="header-anchor" href="#声明式事务的失效情况"><span>声明式事务的失效情况</span></a></h3><ul><li>方法访问权限问题：在非public方法上使用导致失效；</li><li>自调用问题：同一个类中，方法A调用方法B（有事务），导致事务失效；</li><li>异常处理不当：默认只对运行时异常回滚，如果捕获了异常没有抛出，或检查型异常未配置rollbackFor，会导致事务是失效；</li><li>数据库引擎不支持</li><li>多数据源配置错误：没有正确配置事务管理器，或使用了错误的事务管理器；</li><li>传播行为不当</li><li>异步方法调用：@Async注解会导致事务失效；</li><li>Bean未被Spring管理：比如直接new出来的对象，没有通过Spring容器获取；</li><li>事务超时：如果事务执行时间超过timeout设置，会自动回滚；</li></ul><hr><h2 id="mvc" tabindex="-1"><a class="header-anchor" href="#mvc"><span>MVC</span></a></h2><h3 id="工作流程" tabindex="-1"><a class="header-anchor" href="#工作流程"><span>工作流程</span></a></h3><figure><img src="'+s+'" alt="SpringMVC工作流程.png" tabindex="0" loading="lazy"><figcaption>SpringMVC工作流程.png</figcaption></figure><h3 id="springmvc-restful⻛格的接口流程" tabindex="-1"><a class="header-anchor" href="#springmvc-restful⻛格的接口流程"><span>SpringMVC Restful⻛格的接⼝流程</span></a></h3><figure><img src="'+p+'" alt="Restful⻛格的接⼝流程.png" tabindex="0" loading="lazy"><figcaption>Restful⻛格的接⼝流程.png</figcaption></figure><hr>',65))])}const b=e(o,[["render",g],["__file","index.html.vue"]]),S=JSON.parse('{"path":"/article/Java/Spring/","title":"Spring知识点","lang":"zh-CN","frontmatter":{"title":"Spring知识点","category":["Java"],"description":"Spring是一个轻量级、非侵入式的控制反转（IoC）和面向切面（AOP）的框架。","head":[["meta",{"property":"og:url","content":"https://java-st.blog.csdn.net/my-blog/article/Java/Spring/"}],["meta",{"property":"og:site_name","content":"知识库"}],["meta",{"property":"og:title","content":"Spring知识点"}],["meta",{"property":"og:description","content":"Spring是一个轻量级、非侵入式的控制反转（IoC）和面向切面（AOP）的框架。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-08-07T02:26:20.000Z"}],["meta",{"property":"article:modified_time","content":"2025-08-07T02:26:20.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Spring知识点\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-08-07T02:26:20.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"宋涛\\",\\"url\\":\\"https://java-st.blog.csdn.net/\\"}]}"]]},"headers":[{"level":2,"title":"Spring基础","slug":"spring基础","link":"#spring基础","children":[{"level":3,"title":"Spring的特性","slug":"spring的特性","link":"#spring的特性","children":[]},{"level":3,"title":"Spring的七大主要模块","slug":"spring的七大主要模块","link":"#spring的七大主要模块","children":[]},{"level":3,"title":"Spring常用注解","slug":"spring常用注解","link":"#spring常用注解","children":[]},{"level":3,"title":"Spring主要使用的设计模式","slug":"spring主要使用的设计模式","link":"#spring主要使用的设计模式","children":[]}]},{"level":2,"title":"控制反转（IoC）","slug":"控制反转-ioc","link":"#控制反转-ioc","children":[{"level":3,"title":"SpringBean的生命周期","slug":"springbean的生命周期","link":"#springbean的生命周期","children":[]},{"level":3,"title":"Bean定义和依赖定义方式","slug":"bean定义和依赖定义方式","link":"#bean定义和依赖定义方式","children":[]},{"level":3,"title":"依赖注入的方法","slug":"依赖注入的方法","link":"#依赖注入的方法","children":[]},{"level":3,"title":"自动装配","slug":"自动装配","link":"#自动装配","children":[]},{"level":3,"title":"自动装配的方式","slug":"自动装配的方式","link":"#自动装配的方式","children":[]},{"level":3,"title":"@Autowired注解自动装配的过程","slug":"autowired注解自动装配的过程","link":"#autowired注解自动装配的过程","children":[]},{"level":3,"title":"Bean的作用域","slug":"bean的作用域","link":"#bean的作用域","children":[]},{"level":3,"title":"循环依赖","slug":"循环依赖","link":"#循环依赖","children":[]},{"level":3,"title":"循环依赖解决","slug":"循环依赖解决","link":"#循环依赖解决","children":[]},{"level":3,"title":"简易Ioc容器实现","slug":"简易ioc容器实现","link":"#简易ioc容器实现","children":[]},{"level":3,"title":"Spring、Spring MVC和Spring Boot的区别","slug":"spring、spring-mvc和spring-boot的区别","link":"#spring、spring-mvc和spring-boot的区别","children":[]},{"level":3,"title":"Spring启动几乎实例化所有Bean的原因","slug":"spring启动几乎实例化所有bean的原因","link":"#spring启动几乎实例化所有bean的原因","children":[]},{"level":3,"title":"Spring优化启动时间","slug":"spring优化启动时间","link":"#spring优化启动时间","children":[]}]},{"level":2,"title":"面向切面（AOP）","slug":"面向切面-aop","link":"#面向切面-aop","children":[{"level":3,"title":"AOP的理解","slug":"aop的理解","link":"#aop的理解","children":[]},{"level":3,"title":"Spring AOP和AspectJ AOP的区别","slug":"spring-aop和aspectj-aop的区别","link":"#spring-aop和aspectj-aop的区别","children":[]}]},{"level":2,"title":"事务","slug":"事务","link":"#事务","children":[{"level":3,"title":"编程式事务","slug":"编程式事务","link":"#编程式事务","children":[]},{"level":3,"title":"声明式事务","slug":"声明式事务","link":"#声明式事务","children":[]},{"level":3,"title":"Spring的事务隔离级别","slug":"spring的事务隔离级别","link":"#spring的事务隔离级别","children":[]},{"level":3,"title":"声明式事务的失效情况","slug":"声明式事务的失效情况","link":"#声明式事务的失效情况","children":[]}]},{"level":2,"title":"MVC","slug":"mvc","link":"#mvc","children":[{"level":3,"title":"工作流程","slug":"工作流程","link":"#工作流程","children":[]},{"level":3,"title":"SpringMVC Restful⻛格的接⼝流程","slug":"springmvc-restful⻛格的接口流程","link":"#springmvc-restful⻛格的接口流程","children":[]}]}],"git":{"createdTime":1745759920000,"updatedTime":1754533580000,"contributors":[{"name":"stao","username":"stao","email":"2944922490@qq.com","commits":4,"url":"https://github.com/stao"}]},"readingTime":{"minutes":8.13,"words":2439},"filePathRelative":"article/Java/Spring/index.md","localizedDate":"2025年4月27日","excerpt":"<p>Spring是一个轻量级、非侵入式的控制反转（IoC）和面向切面（AOP）的框架。</p>\\n","autoDesc":true}');export{b as comp,S as data};
