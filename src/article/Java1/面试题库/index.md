---
title: 面试题库
author: 宋涛
---

记录面试题的简单回答，便于记忆，实际可按理解扩充。
<!-- more -->

## 基础题

### 1.面向对象和面向过程的区别

面向过程：是分析解决问题的步骤，然后用函数一步步实现，性能高；\
面向对象：是把构成问题的要素拆分成对象，易维护、复用、拓展。

### 2.instanceof关键字段作用

判断一个对象是否为一个类的实例。

### 3.Java自动装箱和拆箱

装箱就是自动将基本数据类型转换为对应的包装类对象；\
拆箱就是自动将包装器类型转换为基本数据类型。

### 4.Hashcode的作用

该方法用于提高查找效率，通过哈希算法分成若干区域，存储元素时通过调用该方法根据哈希值迅速定位到对应到应存储的位置。

### 5.String、StringBuffer、StringBuilder的区别

String：只读字符串，每次使用都会创建一个新对象；\
StringBuffer: 可变字符串，线程安全，效率低；\
StringBuilder: 可变字符串，线程不安全，效率高.

### 6.ArrayList和LinkList的区别

ArrayList：底层是数组，查改效率高，增删效率低；\
LinkList：底层是链表，查改效率低，增删效率高。

### 7.HashMap和HashTable的区别

HashMap：父类为AbstractMap类，key和value可以为空，线程不安全，效率高；\
HashTable：父类为Dictionary类，key和value不能为空，线程安全，效率低。

### 8.Java的四种引用（强软弱虚）

强引用：默认的引用，只要垃圾回收器不进行回收，该对象就不会被回收；\
软引用：内存不足时，会被回收；\
弱引用：JVM垃圾回收器发现了，会被回收；\
虚引用：JVM垃圾回收器发现了，会被回收，但回收前会进入引用队列，可以监听到被回收。

### 9.泛型的特点

在定义类、接口、方法时，添加类型参数，在编译时确定类型。

### 10.Java创建对象的几种方式

new关键字；反射；克隆；序列化。

### 11.浅拷贝和深拷贝的区别

浅拷贝：不复制引用的对象；\
深拷贝：引用的对象也复制。

### 12.final的用法

final修饰类：不能被继承；\
final修饰方法：不能被重写；\
final修饰变量：又称常量，编译会存入常量池，引用不能被修改，但引用的值可变。

### 13.static的用法

修饰方法和变量：转换为静态方法和变量，不用new对象就可以调用;\
修饰代码块：在类加载时执行，只执行一次；\
修饰导入：可直接访问该包下的静态资源。

### 14.a=a+b与a+=b的区别

+=会进行隐式自动类型转换，a=a+b不会。

### 15.Exception和Error的区别

Exception：分为运行时异常和被检查异常，可以捕获；\
Error：编译器不会检查，不能捕获。

### 16.OOM和SOF的区别

OOM：Jvm堆溢出；JVM的栈扩展超出资源容量；常量池溢出；方法区溢出；\
SOF：栈溢出，一般默认为1-2m，一般是死循环和深度递归导致。

### 17.程序、进程、线程的关系

程序：程序包含程序代码和数据，是可执行文件；\
进程：进程是程序的一次执行过程，是资源分配的最小单位；\
线程：也称轻量级进程，是进程内多个执行流的执行单元，线程之间可相互影响。


### 18.Java序列或中某些字段不参与序列化

使用transient关键字修饰，只能修饰变量。

### 19.IO流

按流向分为输入流和输出流，按操作单元分为字节流和字符流，按角色分为节点流和处理流。
![alt text](image.png)

### 20.Java的反射

通过类名，可知该类的所有属性和方法，并动态调用；
可以通过Class.forName()、getClass()、.Class来获取Class对象。

### 21.List、Set、Map的区别

List：有序，可重复；
Set：无序，不可重复；
Map：无序，键值对，键不可重复。

### 22.fail-fast事件

多个线程同时操作同一个集合时，如果其中一个线程修改了集合，就会抛出ConcurrentModificationException异常，产生fail-fast事件，需使用java.util.concurrent包下的集合类。

### 23.HashMap的长度为什么是2的N次方

需要减少hash值的碰撞，保证数据均匀分配，2的N次方将%操作转换成&操作，提高运算效率。

## JVM
![alt text](image-1.png)

### 1.JVM内存模型

线程独占： 栈、本地方法栈、程序计数器；\
线程共享： 堆、方法区；

### 2.类的生命周期

加载字节码文件，验证文件要求，分配内存，解析引用，初始化静态内容，实际使用，GC卸载回收

### 3.双亲委派模式

加载器加载类时，先将请求委托给父类加载器，如果父类不能加载，再自己加载。

### 4.堆和栈的区别

堆：存放对象，线程共享，存储空间大；\
栈：存放局部变量和方法调用，线程私有，存储空间小。

### 5.判断对象是否可被回收

引用计数为0，可达性分析。

### 6.垃圾回收算法

标记清除：标记为0的清除，标记为1的不清除；\
标记整理：标记为1的保留，标记为0的清除，并调整内存地址。\
复制算法：将内存分为两块，每次只使用一块，当一块内存满时，将另一块内存复制到第一块，再使用第一块。\
标记压缩：标记为1的保留，标记为0的清除，并调整内存地址，减少内存碎片。\
分代收集算法：分为新生代和老年代，每次只回收其中一块，当一块内存满时，将另一块内存复制到第一块，再使用第一块。

### 7.JVM调优参数

-Xms：初始堆大小；\
-Xmx：最大堆大小；\
-XX:NewSize：新生代大小；
-XX:MaxNewSize：最大新生代大小；\
-XX:SurvivorRatio：Eden区与Survivor区的比例；\
-XX:+UserParallelGC：使用并行垃圾回收算法（年轻代）；\
-XX:+UseConcMarkSweepGC：使用并发标记清除算法（年老代）; \
...

## 多线程

### 1.实现多线程的方法

1.继承Thread类；\
2.实现Runnable接口；\
3.实现Callable接口；\
4.使用线程池。

### 2.如何停止正在运行的线程

1.使用退出标志；\
2.使用stop方法；\
3.使用interrupt方法。

### 3.notify()和notifyAll()的区别

1.notify()：随机唤醒一个等待线程，可能导致死锁；\
2.notifyAll()：唤醒所有等待线程。

### 4.sleep()和wait()的区别

1.sleep()：属于Thread类，线程休眠，不会释放锁；\
2.wait()：属于Object类，线程等待，会释放锁。

### 5.volatile的作用

1.保证不同线程对同一变量操作的可见性；\
2.禁止指令重排序；\
3.一般用于状态标记量和单例模式的双检锁。
